(in-package :si-kanren)

(defun make-st (S/C D TY A)
  `(,S/C ,D ,TY ,A))

(defun  empty-state () (make-st   '(() . 0) '() '() '()))

(defun S/C-of (s/c/d)
  (car s/c/d))

(defun S-of (s/c/d)
  (caar s/c/d))

(defun C-of (s/c/d)
  (cdar s/c/d))

(defun D-of (s/c/d)
  (cadr s/c/d))

(defun TY-of (s/c/d)
  (caddr s/c/d))

(defun a-of (s/c/d)
  (cadddr s/c/d))

;The `pull`  function is  used to  repeatedly apply  the stream  until it  is no
;longer a function.  This is done by calling the function and passing its result
;back to `pull` recursively until it  is no longer a function.  The final result
;is returned.
(defun pull (st)
  (if (functionp st)
      (pull (funcall st))
      st))

;The `take` function is a utility function in the si-Kanren library that takes a
;specified number of  results from a stream of values  generated by a goal.  The
;function takes two arguments:  `n`,  which represents  the number of results to
;take,  and `st`, which represents the stream of values generated by a goal.  If
;`n` is 0,  an empty list is returned.  Otherwise, the `pull` function is called
;on `st` to get the next item from the stream,  and it is consed with the result
;of recursively  calling `take` with  `n` decremented by  1 and the  rest of the
;stream.  This process continues until `n` reaches 0 or the stream is exhausted,
;at which point an empty list is returned.
(defun take (n st)
  (if (= 0 n) '()
      (let ((st (pull st)))
           (cond
                   ((null? st) '())
                   (t (cons (car st) (take (- n 1) (cdr st))))))))

(defun take-all (st)
  (let ((next (pull st)))
      (if (null? next)
          '()
           (cons (car next) (take-all (cdr next))))))

(defun call/empty-state (g)
  (funcall g (empty-state)))

;Here's how the `reify-s` function works:
;1. If the value `v` is a logical variable, it checks if there is already a value
;assigned to it in `s`.  If so, it returns `s` unchanged. Otherwise, it generates
;a new  name for the  variable by calling  the `reify-name`  function and  adds a
;binding of the form `(lvar . name)` to `s`. The new state `s'` is returned.
;2.  If the value `v` is a pair, it recursively applies `reify-s` to both its car
;and cdr,  and then applies the same  transformation to the resulting states `s1`
;and `s2`. The new state `s'` is returned.
;3.  If the  value `v` is  neither a logical  variable nor a  pair,  it is simply
;returned as it is.
;Overall,  the `reify-s` function is  responsible for replacing logical variables
;with their corresponding values in a state, while keeping track of new names for
;variables.
(defun reify-s (v s)
  (let ((v (walk v s)))
      (cond
           ((lvar? v)
            (let ((n (reify-name (length s))))
                 (cons `(,v . ,n) s)))
           ((pair? v)
            (reify-s (cdr v) (reify-s (car v) s)))
           (t s))))

;The `reify-name` function  is  used  in  the  `reify-s`  function to generate a
;symbol representing  a logic variable.  It takes  an integer  `n` as  input and
;generates a symbol with the name  "_." followed by the string representation of
;`n`.  This symbol is used  as the name for the logic  variable in the `reify-s`
;function.
(defun reify-name (n)
  (make-symbol (concatenate 'string "_." (write-to-string n))))

(defun reify-state/1st-var (s/c/d)
  (labels (( o (ti)
            (let ((v (walk* ti (s-of s/c/d))))
                (walk* v (reify-s v '())))))
   (o (cons (lvar 0)
        (cond
             ((and (null? (d-of s/c/d)) (null? (ty-of s/c/d)))
              nil)
             ((null? (ty-of s/c/d))
              (if (not (equal (cdar (d-of s/c/d)) nil))
                  `(where ,(mapcar (lambda (mini) `(and . ,(mapcar (lambda (dis) `(=/= ,(car dis) ,(cdr dis))) mini)))
                              (cadr s/c/d)))
                  `(where  ,(mapcar (lambda (mini) `,(mapcar (lambda (dis) `(=/= ,(car dis) ,(cdr dis))) mini))
                                 (cadr s/c/d)))))
             ((null? (d-of s/c/d))
              `(with ,(ty-of s/c/d)))
             ((and (d-of s/c/d) (ty-of s/c/d))
              (if (not (equal (cdar (d-of s/c/d)) nil))
                 (cons `(where  ,(mapcar (lambda (mini) `(and . ,(mapcar (lambda (dis) `(=/= ,(car dis) ,(cdr dis))) mini)))
                                  (cadr s/c/d))) `(with ,(ty-of s/c/d)))
                 (cons `(where  ,(mapcar (lambda (mini) `,(mapcar (lambda (dis) `(=/= ,(car dis) ,(cdr dis))) mini))
                                  (cadr s/c/d))) `(with ,(ty-of s/c/d)))))
             (T nil))))))

;The `mK-reify`  function is used  to reify the  state of  the variables  in the
;state-constraint pairs. Here is how the `mK-reify` function works:
;1. It takes a state-constraint pair `s/c/d` as input.
;2.  If the `s/c/d` pair is empty (i.e., there are no variables or constraints),
;it returns nil.
;3. If there are multiple solutions in the state (i.e., there are multiple pairs
;in  `d`),  it normalizes  the state  by removing  any subsumed  constraints and
;removing duplicates in a set theory sense.
;4. It calls the `reify-state/1st-var` function on each state-constraint pair to
;convert the variables to a printable format.
;5. It uses the `format` function to print the variables in a readable format.
;6. If there are multiple solutions, it uses the `format` function to print each
;solution on a new line.
;7.  Finally,  the `mK-reify` function returns the printed result of the reified
;state.
;In summary,  the `mK-reify` function takes a state-constraint pair, reifies the
;state of the  variables,  and returns the result in  a printable format.  It is
;used to display the values of the variables in the state after running a goal.
(defun mK-reify (s/c/d)
    (if (equal nil s/c/d)
        nil)
     ;(if (cdr s/c/d)
         ;(setq s/c/d (mapcar (lambda (l) (remove nil l)) s/c/d))
         ;(setq s/c/d (cons (remove nil (car s/c/d)) '()))))
    (let ((S (apply 'concatenate 'list (map 'list #'reify-state/1st-var s/c/d))))
       (if (cdr S)
           (format t "~{~a~%~^ ~}" S)
           (format t "~{~a~^ ~}" (car S))))
    (values))

;The  `walk*`  function  is  used  to  recursively  process  the  value  `v` and
;substitute any logical variables it contains with their corresponding values in
;the substitution `s`.  If  `v` is a logical variable,  `walk*`  will attempt to
;find its value in `s` and return it. If `v` is a pair, `walk*` will recursively
;apply `walk*`  to both its  car and cdr  values.  If `v`  is neither  a logical
;variable nor a pair, it is treated as a constant value and returned as is.  The
;resulting value after applying `walk*` to `v`  and `s` will be a value with all
;logical variables substituted with their corresponding values.
(defun walk* (v s)
  (let ((v (walk v s)))
      (cond
            ((lvar? v) v)
            ((pair? v)
             (cons (walk* (car v) s)
                   (walk* (cdr v) s)))
            (t v))))


;The `zzz` function is a macro that takes  a goal `g` as an argument and returns
;a lambda function.  It is used to wrap a goal as a function to be called later.
;Here is an explanation of how the `zzz` macro works:
;1. The `zzz` macro takes a goal `g` as its argument.
;2.  It generates a lambda function that  takes a state-constraint pair `s/c` as
;its argument.
;3.  Inside the lambda function,  it calls `pull` on `s/c`.  The `pull` function
;repeatedly applies the state until it is no longer a function,  and returns the
;final result.
;4.  The result  of `pull` is  passed as an  argument to  `g`,  which is  a goal
;function.
;5.  The lambda function returns the result of calling `g` with the pulled state
;as its argument.
;In summary, the `zzz` macro wraps a goal function `g` as a lambda function that
;can be called later with a state-constraint pair to yield a result.
(defmacro zzz (g)
  `(lambda (s/c) (lambda() (funcall ,g s/c))))

(defmacro conj+ (g &rest goals)
  (if goals
       `(conj (zzz ,g) (conj+ ,@goals))
       `(zzz ,g)))

(defmacro disj+ (g &rest goals)
  (if goals
       `(disj (zzz ,g) (disj+ ,@goals))
       `(zzz ,g)))


;The `conde` function is  a macro that is used to define  multiple clauses for a
;goal.  It takes multiple clauses as its arguments,  where each clause is a list
;of goals.  The macro expands into a call to the `disj+` macro, which takes each
;clause  and wraps  it with  the `conj+`  macro.  The `conj+`  macro is  used to
;combine multiple  goals into  a single  goal.  Here's an  example usage  of the
;`conde` macro:
;```
;(conde
  ;((goal1) (goal2))
  ;((goal3) (goal4)))

;```
;This will expand into:
;```
;(disj+
  ;(conj+ (zzz (goal1)) (zzz (goal2)))
  ;(conj+ (zzz (goal3)) (zzz (goal4))))
;```
;The `disj+`  macro combines the  clauses using the  `conj+` macro.  The `conj+`
;macro wraps each  goal  with  the  `zzz`  macro,  which  turns  the goal into a
;function that can be called later.
(defmacro conde (&rest clauses)
  `(symbol-macrolet ((else +succeed+))
    (disj+ ,@(loop for c in clauses collect `(conj+ ,@c)))))

;The `fresh` function in  the  si-Kanren  library  is  a  macro  that is used to
;introduce logical variables  and  define  goals  within  a  local scope.  It is
;similar to the `let` function, but with the addition of logical variables.
;The syntax of the `fresh` macro is as follows:
;```
;(fresh (v1 v2 ...)
  ;goal1
  ;goal2
  ;...)
;```
;- `(v1  v2 ...)`  represents a list  of logical  variables that  are introduced
;within the scope of the `fresh` macro.
;- `goal1` and `goal2` represent the goals that are executed within the scope of
;the `fresh` macro.
;The `fresh` macro can be used to define goals by combining multiple constraints
;and logic variables.  It  provides a way to express  constraints and relational
;logic  in  a declarative  manner.  For  example,  consider  the  following code
;snippet:
;```
;(fresh (x)
  ;(== x 3))
;```
;This code introduces a logical variable  `x` and assigns it the value `3`.  The
;goal `(== x 3)`  constrains `x` to be equal to `3`.  When  the `fresh` macro is
;called, it returns a function that represents the goal.  The goal can be called
;with a state-constraint pair to solve the constraint and retrieve the values of
;the logical  variables.  In summary,  the  `fresh` macro  is used  to introduce
;logical variables and define goals within  a local scope.  It provides a way to
;express constraints and relational logic in a declarative manner.
(defmacro fresh (&rest e)
  (cond
      ((null? (car e)) `(conj+ ,@(cdr e)))
      (t `(call/fresh (lambda (,(car (car e)))
                            (fresh ,(cdr (car e)) ,@(cdr e)))))))

(defmacro runno (num (&rest queries) &body goals)
  (let ((q (gensym)))
    `(take ,num
              (call/empty-state
                         (fresh (,q ,@queries)
                                (conj+
                                  (== `(,,@queries) ,q)
                                  ,@goals))))))

(defmacro run (num (&rest queries) &body goals)
  `(let ((s/c/d (runno ,num (,@queries) ,@goals)))
    (if (null s/c/d)
        nil
        (mK-reify (normalize-conde s/c/d)))))

(defmacro runno* ((&rest queries) &body goals)
  (let ((q (gensym)))
    `(take-all
        (call/empty-state
                   (fresh (,q ,@queries)
                          (conj+
                            (== `(,,@queries) ,q)
                            ,@goals))))))

(defmacro run* ((&rest queries) &body goals)
  `(let ((s/c/d (runno* (,@queries) ,@goals)))
    (if (null s/c/d)
        nil
        (mK-reify (normalize-conde s/c/d)))))

(defmacro nlet-tail (n letargs &rest body)
      (let ((gs (loop for i in letargs
                  collect (gensym)))
            (gb (gensym))
            (gn (gensym)))
         `(macrolet
             ((,n ,gs
               `(progn
                  (psetq
                      ,@(apply #'nconc
                          (mapcar
                              #'list
                              ',(mapcar #'car letargs)
                              (list ,@gs))))
                  (go ,',gn))))
            (block ,gb
              (let ,letargs
                (tagbody
                  ,gn (return-from
                         ,gb (progn ,@body))))))))


(defmacro runi ((&rest queries) &body goals)
      `(let* (($ (runno* (,@queries) ,@goals))
              ($* (normalize-conde $)))
        (nlet-tail named-loop (($* (pull $*)))
           (if (equal $* '())
               (format t "thats-all!~%")
               (values (format t "~{~a~^ ~}~%" (reify-state/1st-var (car $*)))
                       (format t "another? y/n~%")
                       (case (read)
                         ((y yes) (named-loop (pull (cdr $*))))
                         (t (format nil "bye!"))))))))


;;;;;;;;;;;;;;;;;;;;    "Pars construens" of the Reifier     ;;;;;;;;;;;;;;;;;;;;

;;;;;;;;;;;;;;;;;;;;   Normalization of the Disequality Store ;;;;;;;;;;;;;;;;

  ;;;;;;;   Getting rid of constraints subsumed by others constraints  ;;;;;

(defun eigenvalue (v)
  (and (not (subsumed v)) (not (lvar? (cdr v)))))

(defun subsumed (v)
 (if (equal nil v)
     '()
     (if (consp (cdr v))
         t
         nil)))

(defun normalize-subsumed (tree)
   (let ((seen NIL)(lists-seen nil))
     (labels ((rec (l)
               (cond
                 ((null l) NIL)
                 ((member (car l) seen :test #'equal) (rec (cdr l)))
                 ((subsumed (car l))(push (car l) lists-seen)(rec (cdr l)))
                 (T (push (car l) seen) (rec (cdr l))))))
       (rec tree)
      (values seen
              lists-seen))))

(defun normalize-lists-seen (s ls)
  (if (equal nil ls)
      nil
      (if (member (car s) (car ls) :test #'equal-lists)
          (normalize-lists-seen s (cdr ls))
          (cons (car ls)(normalize-lists-seen s (cdr ls))))))

;The `remove-subsumed` function  takes a list of constraints  `d` and removes any
;constraints that are  subsumed by others in the  list.  Subsumed constraints are
;constraints  that  are  more  specific  and  thus  can  be  inferred  from other
;constraints  in  the  list.  The  function  returns  a  list  of  the  remaining
;constraints after the removal.
;Here is a summary of the `remove-subsumed` function:
;1.   The  function  `normalize-subsumed`  is  called  with  the  input  list  of
;constraints `d`.
;2.  The `normalize-subsumed` function takes a  list of constraints and checks if
;any constraint is subsumed by others.
;3.  The `seen` list keeps track of constraints that are not subsumed,  while the
;`lists-seen` list keeps track of lists of constraints that are subsumed.
;4.  The `rec` function is defined to  recursively iterate over the input list of
;constraints.
;5.  In each iteration,  the function checks if the current constraint is already
;in the `seen`  list or if it is  subsumed by any other constraint  in the `seen`
;list.
;6.  If the constraint is already in the `seen` list or is subsumed,  it is added
;to the `lists-seen` list.
;7.  If the constraint is not in the `seen` list and is not subsumed, it is added
;to the `seen` list.
;8. The `rec` function is called with the input list of constraints.
;9.  The `normalize-subsumed` function returns  the `seen` and `lists-seen` lists
;as multiple values.
;10. The `normalize-lists-seen` function is then called to remove duplicates from
;the `lists-seen` list based on the `seen` list.
;11.   The  `normalize-lists-seen`  function  takes   the  `seen`  list  and  the
;`lists-seen` list as arguments.
;12. If the current sublist in the `list-seen` list contains a constraint that is
;already in the `seen` list, it is discarded.
;13.  If the current  sublist  in  the  `lists-seen`  list  does  not contain any
;constraints that are already in the `seen` list, it is added to the result list.
;14. The `normalize-lists-seen` function returns the result list.
;15.  The `remove-subsumed`  function returns the  `seen` list and  the result of
;calling `normalize-lists-seen` with the `seen` list and the `lists-seen` list.
(defun remove-subsumed (d)
  (multiple-value-bind (seen ls-seen)
    (normalize-subsumed d)
    (mapcar (lambda (si) (setq ls-seen (normalize-lists-seen si ls-seen))) seen)
    (cons seen (cons ls-seen '()))))

     ;;;;;;;;   Getting rid of duplicates, in a "set theory" sense   ;;;;;;;;;

(defun norm-cons (xs)
 (if (not (consp (cdr xs)))
     (cons (car xs) (cons (cdr xs)'()))
     (cons (car xs) (norm-cons (cdr xs)))))

(defun dotted-pair-p (arg) (and (not (atom arg)) (not (listp (cdr arg)))))

(defun equal-lists (list1 list2)
  (if (dotted-pair-p list1)
   (and (eq (null (intersection (norm-cons list1) (norm-cons list2) :test #'equalp)) nil)
        (null (set-difference (norm-cons list1) (norm-cons list2) :test #'equalp)))
   '()))

;The `norm=lvars`  function removes duplicate  lvars from a  list of disjunctive
;clauses.  It uses the `equal-lists` function to determine if two lists of lvars
;are equal,  removing duplicates based  on the `equalp` equality predicate.  The
;`dotted-pair-p` function checks if an argument is a dotted pair, which means it
;is not a proper list. The `norm-cons` function converts a list into a canonical
;form for comparison,  where dotted pairs are  represented as a cons cell with a
;single element in the  cdr.  The `norm=lvars` function uses `remove-duplicates`
;to remove duplicate lists of  lvars based on the `equal-lists` predicate.  This
;function applies  `equal-lists` to  each pair of  elements in  the list  `d` to
;determine if they are equal, removing duplicates from the resulting list.
(defun norm=lvars (d)
  (remove-duplicates d :test #'equal-lists))

        ;;;;;;;;;;;;;   Getting rid of "ghost" vars ;;;;;;;;;;;;;;;;;

(defun walk-queries (n s/c/d)
  (labels ((walk-q (s)
             (if (null s)
                 '()
                 (if (lvar=? (lvar n) (caar s))
                     (car s)
                     (walk-q (cdr s))))))
   (let ((s^ (caaar s/c/d)))
     (walk-q s^))))

(defun lvar-or-atom (v l)
  "T if v in walking l is another lvar"
  (if (lvar? l)
      (lvar=? v l)
      (if (not (consp l))
       '()
       (if (null l)
        '()
        (if (lvar? (car l))
            (cons (lvar=? v (car l)) (lvar-or-atom v (cdr l)))
            (lvar-or-atom v (cdr l)))))))

(defun flatten (x)
    (labels ((rec (x acc)
                (cond ((null x) acc)
                      ((typep x 'sb-impl::comma) (rec (sb-impl::comma-expr x) acc))
                      ((atom x) (cons x acc))
                      (t (rec
                            (car x)
                            (rec (cdr x) acc))))))
        (rec x nil)))

(defun flat-d (d)
         (apply 'concatenate 'list
                (apply 'concatenate 'list d)))

;The  `normalize-fresh`  function  is  responsible  for  getting  rid  of  unused
;variables in  the `fresh`  macro.  It takes a  state-constraint pair  `s/c/d` as
;input and  returns a modified version  of `d` that removes  any constraints that
;are not needed.
;Here is a summary of the function:
;1.  It first extracts the constraints `d` from the state-constraint pair `s/c/d`
;using `cdar s/c/d`.
;2. It concatenates all the constraints in `d` using `apply 'concatenate 'list`.
;3.  It removes any constraints that are  subsumed by other constraints using the
;`normalize-subsumed` function, via remove-subsumed.
;4.  It checks  each constraint  in `d`  to see if  it is  unused by  calling the
;`unused` function.
;5. If a constraint is unused, it is removed from `d`.
;6. The resulting `d` is returned as the modified version of `d`.
;The `normalize-fresh` function ensures that  only constraints that are necessary
;are kept in the final `d` list, reducing redundancy and optimizing the execution
;of the `fresh` macro.
(defun normalize-fresh (s/c/d)
      (labels ((norm (l d)
                 (if (null d)
                     '()
                  (if (not (member 't (flatten (mapcar (lambda (x) (lvar-or-atom (caaar d) (walk* x (caaar l)))) (cdr (walk-queries 0 l))))))
                      (norm l (cdr d))
                      (if (unused (caar d) l)
                          (norm l (cdr d))
                          (cons (car d)(norm l (cdr d))))))))
        (let ((d^ (apply 'concatenate 'list (remove-subsumed (cadar s/c/d)))))
         (norm s/c/d d^))))

          ;;;;;;;;;;;   Getting rid of unused vars   ;;;;;;;;;;;;;

;The `unused` function checks if a variable `v` in a list `l` is unused. It does
;this by checking if `v` is an eigenvalue, a symbol, or a pair with a non-symbol
;second element.  If none of these conditions are met,  it checks if `v` is used
;by any of  the constraints in `l`.  It  returns `t` if `v` is  unused and `nil`
;otherwise.
(defun unused (v l)
 (cond
   ((eigenvalue v) nil)
   ((symbolp (cdr v)) nil)
   ((listp (cdr v))(not (symbolp (cadr v))))
   ((member 't (flatten (mapcar (lambda (x) (lvar-or-atom (cdr v) (walk* x (caaar l)))) (cdr (walk-queries 0 l))))) nil)
   ((listp (cdr v))(not (member 't (flatten (mapcar (lambda (x) (lvar-or-atom (cadr v) (walk* x (caaar l)))) (cdr (walk-queries 0 l)))))))
   ((listp (cdr v))(lvar-or-atom (cadr v)(walk* (cadr v) (caaar l))))
   (T (lvar-or-atom (cdr v) (walk* (cdr v) (caaar l))))))

;;;;;;;;;;;;;;;;;;;;;;;; Normalization of the Type Store  ;;;;;;;;;;;;;;;;;;;;;

(defun normalize-TY (s/c/d)
      (labels ((norm (l ty)
                 (if (null ty)
                     '()
                     (if (not (member 't (flatten (mapcar (lambda (x) (lvar-or-atom (caar ty) (walk* x (caaar l)))) (cdr (walk-queries 0 l))))))
                         (norm l (cdr ty))
                         (cons (car ty)(norm l (cdr ty)))))))
              (norm s/c/d (caddar s/c/d))))

(defun drop-pred-T (TY) (mapcar (lambda (ty) (let ((x (car ty))
                                                   (tag (tag-of ty)))
                                                 `(,tag ,x))) TY))

(defun partition* (A)
  (cond ((null? A) '())
        (T (part (car (car A)) A '() '()))))

(defun part (tag A x* y*)
  (cond ((null? A) (cons `(,tag . ,(mapcar #'car x*)) (partition* y*)))
        ((tag=? (car (car A)) tag)
         (let ((x (cdr (car A))))
           (let ((x* (cond ((member x x*) x*)
                           (T (cons x x*)))))
             (part tag (cdr A) x* y*))))
        (T (let ((y* (cons (car A) y*)))
             (part tag (cdr A) x* y*)))))

(defun coerce->l (v) (coerce v 'list))

(defun coerce->v (l) (coerce l 'vector))

(defun sort-part (pr)
  (let ((tag (car pr))
        (x* (mapcar #'coerce->v
                    (mapcar #'unit
                            (sort (apply 'concatenate 'list
                                         (mapcar #'coerce->l (cdr pr))) #'<)))))
    `(,tag . ,x*)))


;;;;;;;;;;;;;;;;;;;;;;;;;  Normalize everything  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

(defun normalize (s/c/d)
  (if (not (cdr s/c/d))
      (norm=lvars (normalize-fresh s/c/d))
      (norm=lvars (normalize-fresh (cons (car s/c/d) nil)))))

;The `normalize-conde` function  takes  a  goal  clause  in  the  form of a conde
;statement and  returns a  normalized version  of it.  The  normalization process
;involves getting rid  of  subsumed  constraints,  removing  duplicates  in a set
;theory sense, getting rid of "ghost" variables, and removing unused variables.

;Here is a summary of the steps involved in the `normalize-conde` function:
;1. Iterate over each clause in the goal clause.
;2. Apply the `normalize-fresh` function to remove "ghost" variables.
;3. Apply the `remove-subsumed` function to remove subsumed constraints.
;4.  Apply the `norm=lvars`  function to remove duplicates in  a set theory sense
;and return the normalized goal clause.

;Overall,  the `normalize-conde` function  ensures that the goal clause  is in a
;normalized form that can be easily processed by the reifier.
(defun normalize-conde (s/c/d)
  (if (null s/c/d)
      '()
      (cons (make-st (caar s/c/d)
                     (normalize s/c/d)
                     (mapcar #'sort-part (partition* (drop-pred-t (normalize-ty s/c/d))))
                     (a-of s/c/d))
           (normalize-conde (cdr s/c/d)))))

;(defun normalize-conde (s/c/d)
  ;(if (null s/c/d)
      ;'()
      ;(cons (cons (caar s/c/d) (cons (normalize s/c/d) ()))
            ;(normalize-conde (cdr s/c/d)))))


;(sort-part  '(num  #(4) #(2) #(3) #(6)))
;(mapcar #'unit (cdr *))
;(mapcar #'coerce->v *)
;(coerce 2 'vector)
;(coerce #(2) 'list)

;(mapcar #'sort-part (partition* '((#(1) sym . symbolp)(#(4) num . numberp))))
;(mapcar #'coerce->l '(#(4) #(1)))
;(coerce '(2) 'vector)

;;(defun prettify (v D TY r)
 ;;(let ((D (sorter (mapcar sorter D)))
       ;;(TY (sorter (mapcar sort-part (partition* TY)))))
   ;;(cond ((and (null? D) (null? TY)) v)
        ;;((null? D) `(,v . ,TY))
        ;;((null? TY) `(,v (=/= . ,D)))
        ;;(T `(,v (=/= . ,D) . ,TY)))))

;;(mapcar (reify-var-state (lvar 0) '((((#(1) . 9) (#(0) . #(1))) . 2) () () ())))
;(purify-t '((#(1) sym . symbolp)(#(2) num . numberp)) '(((((#(0) . #(1)))))))
;(purify-t '((#(1) sym . symbolp)(#(4) num . numberp)) *)
;(unused-in-ty  #(4) *)
;(walk-queries 0 '(((((#(0) . #(1)))))))
;(purify-t '((#(1) sym . symbolp)(#(2) num . numberp)) '((#(1) . cat)(#(2) . 9) (#(0) . #(1))))
;(purify-t '((#(1) sym . symbolp)(#(2) num . numberp)) '((#(1) . cat)(#(2) . 9) (#(0) . #(1))))
;(walk* (drop-pred-t (purify-t '((#(1) sym . symbolp)(#(2) num . numberp))
                            ;'((#(0) . #(1)))))
     ;'((#(0) . #(1))))
;(walk-queries 0 *)
;(walk  #(3) '((#(2) . 9)(#(1) . #(2)) (#(3) . #(1))))
;(unused  '(#(3) . 9)  '((((#(2) . 9) (#(1) . #(2)) (#(4) . #(1))) . 9) () () ()))
;(normalize-fresh  '((((#(2) . #(5)) (#(1) . #(2)) (#(3) . 5)) . 9) (((#(4) . 9))) () ()))
;(normalize-conde(runno 1 (q) (fresh (x y) (=/= x 9)(== q y)(numbero x))))
;(normalize-conde (runno 1 (q) (fresh (x y z p) (=/= x 9)(numbero z)(== q `(,x ,y ,z))(numbero x)(symbolo y))))
;(caddar *)
;(partition* *)
;(normalize-conde (runno 1 (q) (fresh (x y) (=/= x y) (numbero x) (== x q))))
;(cadr *)
;(run 1 (q) (fresh (x y) (=/= x y) (numbero x) (== x q)))
;(run 2 (q) (fresh (x y) (conde ((== x y) (== x 5) (== q y) (numbero q))
                               ;((== x 6) (=/= y x)(== q y)))))
;(normalize-conde (runno 2 (q) (fresh (x y) (conde ((== x y) (== x 5) (== q y) (numbero q))
                                  ;((== x 6) (=/= y x)(== q y)(symbolo y))))))
;(normalize-conde (runno 1 (q) (fresh (x y z)(numbero z)(numbero x)(== q `(,x ,z ,y)) (numbero y))))
;(runno 1 (q) (fresh (x y) (== x y) (=/= y 9) (== q x)))
;(run 1 (q) (fresh (x y) (== x y) (=/= y 9) (== q x)))
;(runno 1 (q) (fresh (x y) (== x y) (=/= y 9)(== y 10) (== q `(,x ,y))))
;(run 1 (q) (fresh (x y) (== x y) (=/= y 9)(== y 10) (== q `(,x ,y))))
;(runno 1 (q) (fresh (x y z) (== x y) (=/= `(,y 9) `(45 ,z)) (numbero x) (== q `(,x ,y ,z))))
;(normalize-conde *)
;(d-of (car *))
;(cadr **)
;(run 1 (q) (fresh (x y z) (== x y) (=/= `(,y 9) `(45 ,z)) (numbero x) (== q `(,x ,y ,z))))
;(unit '(3))
;(run 1 (q) (fresh (x y) (== x y) (=/= y 9)(numbero y) (== q `(,x ,y))))
;(reify-state/1st-var (car *))
;(runno 1 (q) (fresh (x y z) (== x y) (=/= y 9)(numbero z) (== q `(,x ,y))))
;(run 1 (q) (fresh (x y z) (== x y) (=/= y 9)(numbero z) (== q `(,x ,y))))
;(runno 1 (q) (fresh (x y) (== x y) (=/= y 'cat)(numbero x) (== q `(,x ,y))))
;(run 1 (q) (fresh (x y) (== x y) (=/= y 'cat)(numbero x) (== q `(,x ,y))))
;(walk* * '((#(1) . cat)(#(2) . 9) (#(0) . #(1))))
;(run 1 (q) (fresh (x y z w) (=/= `(,x 12) `(9 ,y)) (== z w) (=/= z 42) (== q`(,x ,y ,z ,w))))
;(runno 1 (q) (fresh (x y z w) (=/= `(,x 12) `(9 ,y)) (== z w) (=/= z 42) (== q`(,x ,y ,z ,w))))
;(runno 1 (q) (fresh (x y z w) (=/= `(,x 12) `(9 ,y)) (=/= z 42) (== q`(,x ,y ,w))))
;(run 1 (q) (fresh (x y z w) (=/= `(,x 12) `(9 ,y))(numbero x) (=/= z 42) (== q`(,x ,y ,w))))
;(runno 1 (q) (fresh (x y z w) (=/= `(,x 12) `(9 ,y))(numbero x) (=/= z 42) (== q`(,x ,y ,w))))
;(run 1 (q) (== q 9))
;(car *)
;(d-of *)
;(cdar *)
;(car **)
;(cdr **)
;(run 1 (q) (fresh (x y z w)(numbero x) (=/= `(,x 12) `(9 ,y)) (== z w) (=/= z 42) (== q`(,x ,y ,z ,w))))
;(runno 1 (q) (fresh (x y z w) (=/= `(,x 12) `(9 ,y)) (== z w) (=/= z 42) (== q`(,x ,y ,z ,w))))
;(normalize-conde *)
;(map 'list #'reify-state/1st-var *)
;(run 1 (q) (fresh (x y) (== x y)(numbero y) (== q `(,x ,y))))
